function [bestScores, gen_hv] = run_nmopso(model, params)
    M = 4;
    problemIndex = 3;
    if isfield(params, 'problemIndex')
        problemIndex = params.problemIndex;
    end

    % Override model resolution
    model.n = 10;

    if isfield(params, 'ablationStudy') && logical(params.ablationStudy)
        variants = get_ablation_variants(params);
        summary = struct('name', {}, 'scores', {});
        for v = 1:numel(variants)
            paramsVariant = params;
            paramsVariant.ablation = variants(v);
            variantName = variants(v).name;
            if isempty(variantName)
                variantName = sprintf('variant_%d', v);
                paramsVariant.ablation.name = variantName;
            end
            paramsVariant.resultsDir = fullfile(params.resultsDir, variantName);
            runScores = run_nmopso_variant(model, paramsVariant, problemIndex, M);
            summary(v).name = variantName;
            summary(v).scores = runScores;
        end
        bestScores = summary;
        gen_hv = [];
        if isfield(params, 'computeMetrics') && logical(params.computeMetrics)
            save(fullfile(params.resultsDir, 'ablation_summary.mat'), 'summary');
        end
    else
        bestScores = run_nmopso_variant(model, params, problemIndex, M);
    end
end

function runScores = run_nmopso_variant(model, params, problemIndex, M)
    resultsPath = fullfile(params.resultsDir, params.problemName);
    if ~isfolder(resultsPath), mkdir(resultsPath); end

    computeMetrics = false;
    if isfield(params, 'computeMetrics')
        computeMetrics = logical(params.computeMetrics);
    end

    useParallel = true;
    if isfield(params, 'useParallel')
        useParallel = logical(params.useParallel);
    end

    parallelMode = 'parfor';
    if isfield(params, 'parallelMode')
        parallelMode = params.parallelMode;
    end

    if computeMetrics
        runScores = zeros(params.Runs, 2);
    else
        runScores = [];
    end

    if useParallel
        if strcmpi(parallelMode, 'parfeval')
            pool = gcp('nocreate');
            if isempty(pool)
                parpool;
            end
            futures(params.Runs, 1) = parallel.FevalFuture;
            for run = 1:params.Runs
                futures(run) = parfeval(@nmopso_single_run, 1, model, params, run, ...
                    computeMetrics, problemIndex, resultsPath, M);
            end
            for idx = 1:params.Runs
                [runIdx, score] = fetchNext(futures);
                if computeMetrics && ~isempty(score)
                    runScores(runIdx, :) = score;
                end
            end
        else
            if computeMetrics
                parfor run = 1:params.Runs
                        runScores(run, :) = nmopso_single_run(model, params, run, ...
                        computeMetrics, problemIndex, resultsPath, M);
                end
            else
                parfor run = 1:params.Runs
                    nmopso_single_run(model, params, run, computeMetrics, ...
                        problemIndex, resultsPath, M);
                end
            end
        end
    else
        for run = 1:params.Runs
            score = nmopso_single_run(model, params, run, computeMetrics, ...
                problemIndex, resultsPath, M);
            if computeMetrics && ~isempty(score)
                runScores(run, :) = score;
            end
        end
    end

    if computeMetrics
        save(fullfile(resultsPath, 'final_hv.mat'), 'runScores');
    end
end

function variants = get_ablation_variants(params)
    if isfield(params, 'ablationVariants') && ~isempty(params.ablationVariants)
        variants = params.ablationVariants;
        return;
    end
    variants = struct('name', {}, 'useRepository', {}, 'useGrid', {}, ...
                      'useMutation', {}, 'useAdaptiveMutation', {}, 'useRegionMutation', {}, ...
                      'representation', {}, 'useReferenceLeader', {}, 'useTwoLayerRef', {}, ...
                      'nRep', {}, 'nGrid', {}, 'alpha_grid', {}, 'beta', {}, 'gamma', {}, ...
                      'w', {}, 'wdamp', {}, 'c1', {}, 'c2', {}, 'mu', {}, 'delta', {}, ...
                      'metricInterval', {});

    variants(end+1) = struct('name', 'baseline', ...
        'useRepository', true, 'useGrid', true, ...
        'useMutation', true, 'useAdaptiveMutation', true, 'useRegionMutation', true, ...
        'representation', 'SC', 'useReferenceLeader', false, 'useTwoLayerRef', false, ...
        'nRep', 50, 'nGrid', 5, 'alpha_grid', 0.1, 'beta', 2, 'gamma', 2, ...
        'w', 1, 'wdamp', 0.98, 'c1', 1.5, 'c2', 1.5, 'mu', 0.5, 'delta', 20, ...
        'metricInterval', 100);

    variants(end+1) = struct('name', 'no_repository', ...
        'useRepository', false, 'useGrid', false, ...
        'useMutation', true, 'useAdaptiveMutation', true, 'useRegionMutation', true, ...
        'representation', 'SC', 'useReferenceLeader', false, 'useTwoLayerRef', false, ...
        'nRep', 50, 'nGrid', 5, 'alpha_grid', 0.1, 'beta', 2, 'gamma', 2, ...
        'w', 1, 'wdamp', 0.98, 'c1', 1.5, 'c2', 1.5, 'mu', 0.5, 'delta', 20, ...
        'metricInterval', 100);

    variants(end+1) = struct('name', 'no_grid', ...
        'useRepository', true, 'useGrid', false, ...
        'useMutation', true, 'useAdaptiveMutation', true, 'useRegionMutation', true, ...
        'representation', 'SC', 'useReferenceLeader', false, 'useTwoLayerRef', false, ...
        'nRep', 50, 'nGrid', 5, 'alpha_grid', 0.1, 'beta', 2, 'gamma', 2, ...
        'w', 1, 'wdamp', 0.98, 'c1', 1.5, 'c2', 1.5, 'mu', 0.5, 'delta', 20, ...
        'metricInterval', 100);

    variants(end+1) = struct('name', 'no_adaptive_mutation', ...
        'useRepository', true, 'useGrid', true, ...
        'useMutation', true, 'useAdaptiveMutation', false, 'useRegionMutation', true, ...
        'representation', 'SC', 'useReferenceLeader', false, 'useTwoLayerRef', false, ...
        'nRep', 50, 'nGrid', 5, 'alpha_grid', 0.1, 'beta', 2, 'gamma', 2, ...
        'w', 1, 'wdamp', 0.98, 'c1', 1.5, 'c2', 1.5, 'mu', 0.5, 'delta', 20, ...
        'metricInterval', 100);

    variants(end+1) = struct('name', 'no_mutation', ...
        'useRepository', true, 'useGrid', true, ...
        'useMutation', false, 'useAdaptiveMutation', false, 'useRegionMutation', false, ...
        'representation', 'SC', 'useReferenceLeader', false, 'useTwoLayerRef', false, ...
        'nRep', 50, 'nGrid', 5, 'alpha_grid', 0.1, 'beta', 2, 'gamma', 2, ...
        'w', 1, 'wdamp', 0.98, 'c1', 1.5, 'c2', 1.5, 'mu', 0.5, 'delta', 20, ...
        'metricInterval', 100);

    variants(end+1) = struct('name', 'no_region_mutation', ...
        'useRepository', true, 'useGrid', true, ...
        'useMutation', true, 'useAdaptiveMutation', true, 'useRegionMutation', false, ...
        'representation', 'SC', 'useReferenceLeader', false, 'useTwoLayerRef', false, ...
        'nRep', 50, 'nGrid', 5, 'alpha_grid', 0.1, 'beta', 2, 'gamma', 2, ...
        'w', 1, 'wdamp', 0.98, 'c1', 1.5, 'c2', 1.5, 'mu', 0.5, 'delta', 20, ...
        'metricInterval', 100);

    variants(end+1) = struct('name', 'cartesian_representation', ...
        'useRepository', true, 'useGrid', true, ...
        'useMutation', true, 'useAdaptiveMutation', true, 'useRegionMutation', true, ...
        'representation', 'CC', 'useReferenceLeader', false, 'useTwoLayerRef', false, ...
        'nRep', 50, 'nGrid', 5, 'alpha_grid', 0.1, 'beta', 2, 'gamma', 2, ...
        'w', 1, 'wdamp', 0.98, 'c1', 1.5, 'c2', 1.5, 'mu', 0.5, 'delta', 20, ...
        'metricInterval', 100);

    variants(end+1) = struct('name', 'reference_point_leader', ...
        'useRepository', true, 'useGrid', true, ...
        'useMutation', true, 'useAdaptiveMutation', true, 'useRegionMutation', true, ...
        'representation', 'SC', 'useReferenceLeader', true, 'useTwoLayerRef', false, ...
        'nRep', 50, 'nGrid', 5, 'alpha_grid', 0.1, 'beta', 2, 'gamma', 2, ...
        'w', 1, 'wdamp', 0.98, 'c1', 1.5, 'c2', 1.5, 'mu', 0.5, 'delta', 20, ...
        'metricInterval', 100);

    variants(end+1) = struct('name', 'reference_point_leader_2layer', ...
        'useRepository', true, 'useGrid', true, ...
        'useMutation', true, 'useAdaptiveMutation', true, 'useRegionMutation', true, ...
        'representation', 'SC', 'useReferenceLeader', true, 'useTwoLayerRef', true, ...
        'nRep', 50, 'nGrid', 5, 'alpha_grid', 0.1, 'beta', 2, 'gamma', 2, ...
        'w', 1, 'wdamp', 0.98, 'c1', 1.5, 'c2', 1.5, 'mu', 0.5, 'delta', 20, ...
        'metricInterval', 100);

    variants(end+1) = struct('name', 'improved_hv', ...
        'useRepository', true, 'useGrid', true, ...
        'useMutation', true, 'useAdaptiveMutation', true, 'useRegionMutation', false, ...
        'representation', 'SC', 'useReferenceLeader', false, 'useTwoLayerRef', false, ...
        'nRep', 80, 'nGrid', 8, 'alpha_grid', 0.1, 'beta', 1.5, 'gamma', 2, ...
        'w', 0.9, 'wdamp', 0.98, 'c1', 1.7, 'c2', 1.7, 'mu', 0.4, 'delta', 20, ...
        'metricInterval', 100);
end
